

# 1、网络编程



## 1.1、IP地址的介绍

IP 地址就是**标识网络中设备的一个地址**，好比现实生活中的家庭地址。

![](python(六).assets/1.png)

说明：

- IP 地址分为两类： **IPv4** 和 **IPv6**
- IPv4 是目前使用的ip地址
- IPv6 是未来使用的ip地址
- IPv4 是由点分十进制组成
- IPv6 是由冒号十六进制组成

### 1.1.1、IP地址的作用

IP 地址的作用是**标识网络中唯一的一台设备的**，也就是说通过IP地址能够找到网络中某台设备。

![](python(六).assets/2.png)



### 1.1.2、查看IP地址

- Linux 和 mac OS 使用 **ifconfig** 这个命令
- Windows 使用 **ipconfig** 这个命令

**ifconfig** 和 **ipconfig** 都是查看网卡信息的，网卡信息中包括这个设备对应的IP地址

![](python(六).assets/3.png)



### 1.1.3、检查网络是否正常

- 检查网络是否正常使用 ping 命令

![](python(六).assets/4.png)



说明：

- ping www.baidu.com 检查是否能上公网
- ping 当前局域网的ip地址 检查是否在同一个局域网内

- ping 127.0.0.1 检查本地网卡是否正常



## 1.2、端口和端口号

不同电脑上的飞秋之间进行数据通信，它是如何保证把数据给对应软件而不是给其它软件呢?

**其实，每运行一个网络程序都会有一个端口，想要给对应的程序发送数据，找到对应的端口即可。**

![](python(六).assets/5.png)



### 1.2.1、什么是端口

**端口是传输数据的通道**，好比教室的门，**是数据传输必经之路**。

那么如何准确的找到对应的端口呢?

**其实，每一个端口都会有一个对应的端口号，好比每个教室的门都有一个门牌号，想要找到端口通过端口号即可。**

![](python(六).assets/6.png)



### 1.2.2、什么是端口号

操作系统为了统一管理这么多端口，**就对端口进行了编号**，这就是端口号，**端口号其实就是一个数字**，好比我们现实生活中的门牌号,端口号有65536个。

那么最终飞秋之间进行数据通信的流程是这样的，**通过ip地址找到对应的设备，通过端口号找到对应的端口，然后通过端口把数据传输给应用程序**。

![](python(六).assets/7.png)





### 1.2.3、端口和端口号的关系

端口号可以标识唯一的一个端口。



### 1.2.4、端口号的分类

- 知名端口号
- 动态端口号

知名端口号：

知名端口号是指**众所周知的端口号，范围从0到1023。**这些端口号一般固定分配给一些服务，比如21端口分配给FTP(文件传输协议)服务，25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务。

动态端口号：

一般程序员**开发应用程序使用端口号称为动态端口号, 范围是从1024到65535。**如果程序员开发的程序没有设置端口号，操作系统会在动态端口号这个范围内随机生成一个给开发的应用程序使用。当运行一个程序默认会有一个端口号，当这个程序退出时，所占用的这个端口号就会被释放。



## 1.3、TCP的介绍

### 1.3.1、网络应用程序之间的通信流程

之前我们学习了 IP 地址和端口号，通过 IP 地址能够找到对应的设备，然后再通过端口号找到对应的端口，再通过端口把数据传输给应用程序，**这里要注意，数据不能随便发送，在发送之前还需要选择一个对应的传输协议，保证程序之间按照指定的传输规则进行数据的通信，** 而这个传输协议就是我们今天学习的 TCP。

### 1.3.2、TCP的概念

TCP 的英文全拼(Transmission Control Protocol)简称**传输控制协议**，它是一种**面向连接的、可靠的、基于字节流的传输层通信协议**。

![](python(六).assets/8.png)



**TCP 通信步骤:**

1. 创建连接
2. 传输数据
3. 关闭连接



说明：

TCP 通信模型相当于生活中的’打电话‘，在通信开始之前，一定要先建立好连接，才能发送数据，通信结束要关闭连接。



### 1.3.3、TCP的特点

1. 面向连接
   - 通信双方必须先建立好连接才能进行数据的传输，数据传输完成后，双方必须断开此连接，以释放系统资源。
2. 可靠传输
   - TCP 采用发送应答机制
   - 超时重传
   - 错误校验
   - 流量控制和阻塞管理



### 1.3.4、总结

TCP 是一个**稳定、可靠的传输协议，常用于对数据进行准确无误的传输，比如: 文件下载，浏览器上网**。



## 1.4、socket的介绍

到目前为止我们学习了 ip 地址和端口号还有 tcp 传输协议，为了保证数据的完整性和可靠性我们使用 tcp 传输协议进行数据的传输，为了能够找到对应设备我们需要使用 ip 地址，为了区别某个端口的应用程序接收数据我们需要使用端口号，那么通信数据是如何完成传输的呢？

答案：使用 socket 来完成。

### 1.4.1、socket概念

socket(简称套接字) 是**进程之间通信一个工具**，好比现实生活中的**插座**，所有的家用电器要想工作都是基于插座进行，**进程之间想要进行网络通信需要基于这个 socket**。

![](python(六).assets/9.png)



### 1.4.2、socket的作用

负责**进程之间的网络数据传输**，好比数据的搬运工。

![](python(六).assets/10.png)



2个进程之间通过Socket进行相互通讯，就必须有服务端和客户端

- **Socket服务端**：等待其它进程的连接、可接受发来的消息、可以回复消息
- **Socket客户端**：主动连接服务端、可以发送消息、可以接收回复

![](python(六).assets/11.png)



## 1.5、TCP网络应用程序开发流程

TCP 网络应用程序开发分为：

- TCP 客户端程序开发
- TCP 服务端程序开发

说明：

客户端程序是指运行在**用户设备上的程序**，服务端程序是指运行在**服务器设备上的程序**，专门为客户端提供数据服务。

> 1. 主动发起建立连接请求的是客户端程序
> 2. 等待接收连接请求的是服务端程序

### 1.5.1、网络程序通信的流程

1. 通过ip地址找到网络中的设备
2. 通过端口号找到对应进程的端口
3. 传输数据是还需要使用传输协议(tcp),保证数据的可靠性
4. socket完成进程之间网络数据的传输

### 1.5.2、TCP客户端程序开发

1. 创建客户端套接字对象
2. 和服务端套接字建立连接
3. 发送数据
4. 接收数据
5. 关闭客户端套接字





## 1.6、Socket服务端编程

1. 创建socket对象

```python
import socket
socket_server = socket.socket()
```

2. 绑定socket_server到指定IP和地址

```python
socket_server.bind(host,port)
```

3. 服务端开始监听端口

```python
socket_server.listen(backlog)
# backlog为 int 整数,表示允许的连接数量,超出的会等待,可以不填,不填会自动设置一个合理值
```

4. 接收客户端连接，获得连接对象

```python
conn, address = socket_server.accept()
print(f"接收到客户端连接，连接来自:{address}")
# accept 方法是阻塞方法,如果没有连接，会卡在当前这一行,不向下执行代码
# accept 返回的是一个二元元组,可以使用上述形式,用两个变量接收二元元组的2个元素
```

5. 客户端连接后，通过`recv`方法，接收客户端发送的消息

```python
# 可以通过 while True 无限循环来持续和客户端进行数据交互
while True:
    # recv 方法返回值是字节数组,可以通过decode使用UTF-8解码为字符串
    # recv 方法的传参是buffsize,缓冲区大小,一般设置为1024即可
    data = conn.recv(1024).decode("UTF-8")
    # 可以通过判定客户端发来的特殊标记，如exit，来退出无限循环
    if data == 'exit':
        break
    print("接收到发送来的数据:",data)
```

6. 通过 conn（客户端当次连接对象），调用 send 方法可以回复消息

```python
# 可以通过 while True 无限循环来持续和客户端进行数据交互
while True:
    # recv 方法返回值是字节数组,可以通过decode使用UTF-8解码为字符串
    # recv 方法的传参是buffsize,缓冲区大小,一般设置为1024即可
    data = conn.recv(1024).decode("UTF-8")
    # 可以通过判定客户端发来的特殊标记，如exit，来退出无限循环
    if data == 'exit':
        break
    print("接收到发送来的数据:",data)
    
    conn.send("Hello呀".encode("UTF-8"))
```

7. conn（客户端当次连接对象）和 socket_server 对象调用 close 方法，关闭连接







### 1.6.1、实现服务端并结合客户端进行测试













## 1.7、Socket客户端编程

1. 创建socket对象

```python
import socket
socket_client = socket.socket()
```

2. 连接到服务端

```python
socket_client.connect(("localhost",8888))
```

3. 客户端发送消息

```python
# 可以通过 while True 无限循环来持续和客户端进行数据交互
while True:
    send_msg = input("请输入要发送的消息")
    if send_msg = 'exit':
        break
    send_client.send((send_msg.encode("UTF-8")))
```

4. 客户端接收返回消息

```python
while True:
    send_msg = input("请输入要发送的消息").encode("UTF-8")
    send_client.send(send_msg)
    
    # 1024是缓冲区大小,一般写 1024 即可
    recv_data = socket_client.recv(1024)
    
    # recv方法是阻塞式的，即不接收到返回，就卡在这里等待
    print("服务端回复消息为：", recv_data.decode("UTF-8"))
```

5. 关闭连接

```python
send_client.close()
```





### 1.7.1、服务端客户端通信





















