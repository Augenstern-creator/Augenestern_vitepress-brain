# 1、Dubbo

分布式架构耳熟能详，下图就展示了一个典型的分布式系统架构。

- 三台Nginx分别负载均衡各自挂了四个服务
- 两台F5硬设备进行硬负载均衡，用于将流量打到多个Nginx上，由Nginx进行流量转发

![](Dubbo(一).assets/1.png)

## 1.1、RPC简介

RPC(Remote Procedure Call)远程过程调用，它是一种通过网络从远程计算机程序上请求服务。

> 大白话：像调用本地服务一样调用远程服务

RPC的作用：

- 屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法
- 隐藏底层网络通信的复杂性，让我们更加专注业务逻辑。

常见的RPC技术和框架：

- 阿里的 Dubbo/Dubbox
- Google gRPC
- Spring Cloud OpenFeign



## 1.2、Dubbo简介

![](Dubbo(一).assets/2.png)

Apache Dubbo是一款高性能、轻量级的开源服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。那么Dubbo可以做什么呢？

1. 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。
2. 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。
3. 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的iP地址，并且能
   够平滑添加或删除服务提供者



![](Dubbo(一).assets/3.png)



例如工程A调用工程B，工程B可能有三台机器，那么使用Dubbo就可以对工程B的调用做到负载均衡，这就是Dubbo的软负载均衡。

> Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可。





## 1.3、Dubbo核心组件

### 1.3.1、注册中心Registry

在Dubbo微服务体系中，注册中心是其核心组件之一。Dubbo通过注册中心实现了分布式环境中各服务之间的注册与发现，是各个分布式节点之间的纽带。

主要作用：

- 动态加入：一个服务提供者通过注册中心可以动态地把自己暴露给其他消费者，无须消费者逐个去更新配置文件。
- 动态发现：一个消费者可以动态地感知新的配置、路由规则和新的服务提供者，无须重启服务使之生效。
- 动态调整：注册中心支持参数的动态调整，新参数自动更新到所有相关服务节点。
- 统一配置：避免了本地配置导致每个服务的配置不一致问题。

常见的注册发现服务:

- zookeeper
- eureka
- nacos
- consul



### 1.3.2、监控中心Monitor

主要负责监控统计调用次数和调用时间等。



### 1.3.3、工作流程

1. 服务提供者启动过程
   - 服务提供者启动时，会向注册中心Zookeeper集群注册自己提供的服务，包括服务接口、版本、分组等信息。
   - 注册中心Zookeeper集群收到服务提供者的注册信息后，将其存储在本地(同步给其他Zookeeper)，并定期将更新的服务信息同步到其他节点。
   - 服务提供者还会定期从注册中心获取服务消费者的地址列表，以便后续的远程调用。

2. 服务消费者启动过程
   - 服务消费者启动时，会向注册中心订阅自己感兴趣的服务，包括服务接口、版本、分组等信息。
   - 注册中心收到服务消费者的订阅请求后，将匹配的服务提供者地址列表发送给服务消费者。
   - 服务消费者根据获取的地址列表，建立与服务提供者的连接。

3. 远程调用过程
   - 服务消费者根据负载均衡策略，选择一个合适的服务提供者进行远程调用。
   - 通过RPC协议，服务消费者将请求消息发送给服务提供者。
   - 服务提供者接收到请求消息后，解析出请求参数，然后调用本地对应的服务实现进行处理，并将结果通过RPC协议返回给服务消费者。
4. 服务调用监控和管理
   - Dubbo支持对服务调用的性能、成功率、错误率等指标进行监控，方便管理员及时发现和解决问题。
   - Dubbo还提供了丰富的服务治理能力，如动态配置、路由规则、限流熔断等，帮助开发者更好地管理和维护分布式系统。

5. 服务下线和更新
   - 当服务提供者需要下线或更新服务时，可以向注册中心发送注销或更新通知。
   - 注册中心收到通知后，会将其广播到其他书点，以便及时更新服务信息。







## 1.4、地址缓存

假如注册中心Dubbo(Zookeeper)挂掉了，服务间是否还可以远程调用？

答案：可以，因为dubbo服务消费者在第一次调用时，会将服务提供方地址缓存到本地，以后在调用则不会访问注册中心。服务提供者地址发生变化时，注册中心会通服务消费者。





## 1.5、超时机制

- Dubbo的超时配置可以配置在生产者和消费者两端，但一般建议将超时时间配置在生产者端。
- 因为生产者端更贴近业务实现，对超时时间的把握更准确，而消费者端更多的是调用服务，超时时间可以相对宽松一些。
- 同时，在配置超时时间时，需要考虑方法的实际执行时间、网络延迟等因素，避免超时时间设置过短导致调
  用失败。

> Dubbo在服务间调用不成功时，默认会重试2次，注解如下
>
> ```java
> @Service(timeout = 2000,retries = 2)
> ```
>
> 注意：
>
> - @Service 这个注解是dubbo的用于暴露服务的注解。而不是spring的那个注解！
> - timeout为调用该服务的超时时间
> - retries为服务调用失败的重试次数



## 1.6、灰度发布

Dubbo提供多版本的配置，方便我们做服务的灰度发布，或者是解决不兼容的问题。

![](Dubbo(一).assets/4.png)

> 灰度发布（金丝雀发布）：
> 当出现新功能时，会让一部分用户先使用新功能，用户反馈没问题时，再将所有用户迁移到新功能。

版本迁移步骤

1. 在低压力时间段，先升级一半提供者为新版本
2. 再将所有消费者升级为新版本
3. 然后将剩下的一半提供者升级为新版本

```java
@Service(timeout = 2000, version = "1.0",retries = 2)
```



## 1.7、负载均衡

Dubo是一个分布式服务框架，能避免单点故障和支持服务的横向扩容。一个服务通常会部署多个实例。如何从多个服务Provider 组成的集群中挑选出一个进行调用，就涉及到一个负载均衡的策略。

Dubbo内置负载均衡策略:

1. RandomLoadBalance:随机负载均衡，随机的选择一个，默认负载均衡。
2. RoundRobinLoadBalance:轮询负载均衡。
3. LeastActiveLoadBalance:最少活跃调用数，相同活跃数的随机。
4. ConsistentHashLoadBalance:一致性哈希负载均衡，相同参数的请求总是落在同一台机器上。

配置的时候可以在生产端配置，也可以在消费端配置：

生产端：

```java
@Service(version = "2.0",loadbalance = "roundrobin")
```

消费端：

```java
@Reference(version = "2.0",loadbalance = "random")
```

> - random:随机负载均衡
> - leastactive:最少活跃调用数，相同活跃数的随机
> - roundrobin:轮询负载均衡
> - consistenthash:一致性哈希负载均衡



## 1.8、集群容错

Dubbo框架为服务集群容错提供了一系列好的解决方案，在此称为dubbo服务集群容错模式。容错模式如下：

1. Failover Cluster:失败重试。默认值。当出现失败，重试其它服务器，默认重试2次，使用retries配置。一般用于读操作
2. Failfast Cluster:快速失败，只发起一次调用，失败立即报错。通常用于写操作。
3. Failsafe Cluster:失败安全，出现异常时，直接忽略。返回一个空结果。日志不重要操作。
4. Failback Cluster:失败自动恢复，后台记录失败请求，定时重发。非常重要的操作。
5. Forking Cluster:并行调用多个服务器，只要有一个成功即返回。
6. Broadcast Cluster:广播调用所有提供者，逐个调用，任意一台报错则报错。同步要求高的可以使用这个模
   式。

```java
@Service(version = " 2.0",cluster = "failover")
```

- `failover`:Dubbo容错机制的默认值。当出现失败的时候，会尝试其他服务。用户可以通过`retries="2"`设置重试次数。这是Dubbo的默认容错机制，会对请求做负载均衡。	
- `failfast`：快速失败，当请求失败之后快速返回异常结果，不做任何重试。
- `failsafe`:当出现异常的时候直接忽略异常，会对请求做负载均衡。通常的使用场景是不关心调用是否成功，并且不想抛出异常影响外部调用，如某些不重要的日志同步，及时出现异常也无所谓。
- `failback`：请求失败之后，会自动记录在失败队列中，并由一个定时线程池定时重试，适用一些异步或者最终以执行的请求。会对请求做负载均衡。
- `forking`:同时调用多个相同的服务，只要其中一个返回，就立即返回结果。用户可以配置`forks="2"` 来设置最大并行数。
- `broadcast`：广播调用所有可用服务，任意一个节点报错则报错。由于是广播，因此请求不需要做负载均衡。



## 1.9、服务降级

- 服务降级，当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。比如一下子来了2w请求，可以将不重要的请求丢弃，将核心的请求响应。
  
- 当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。

两种场景：

1. 当下游的服务因为某种原因响应过慢，下游服务主动停掉一些不太重要的业务，释放出服务器资源，增加
   响应速度！
2. 当下游的服务因为某种原因不可用，上游主动调用本地的一些降级逻辑，避免卡顿，迅速返回给用户

### 1.9.1、服务降级方式

1. 第一种：

```java
@Reference(mock = "force:return null")
```

表示消费方对该服务的方法调用都直接返回null值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。

2. 第二种

```java
@Reference(mock = "fail:return null")
```

表示消费方对该服务的方法调用在失败后，再返回null值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。





## 1.10、服务限流

验证码就是一种限流手段。限流算法有如下几种：

### 1.10.1、漏桶算法

![](Dubbo(一).assets/5.png)





漏桶算法思路很简单，水（清求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。



### 1.10.2、令牌算法

![](Dubbo(一).assets/6.png)



令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。



### 1.10.3、漏桶VS令牌桶

漏桶的天然特性决定了它不会发生突发流量，就算每秒1000个请求到来，那么它对后台服务输出的访问速率永远
恒定。而令牌桶侧不同，其特性可以“预存”一定量的令牌，因此在应对突发流量的时候可以在短时间消耗所有令
牌，其突发流量处理效率会比漏桶高，但是导向后台系统的压力也会相应增多。



### 1.10.4、Dubbo限流实现

为了防止某个消费者的QPS或是所有消费者的QPS总和突然飙升而导致的重要服务的失效，系统可以对访问流量进行控制，这种对集群的保护措施称为**服务限流**。

1. 并发控制

```java
// 服务端并发执行(或占用线程池线程数)不能超过10个
@Service(executes = 10)
```

2. 连接控制

```java
// 占用连接的请求的数不能超过10个
@Service(actives = 10)
```

Dubbo的限流算法采用了滑动窗口算法。滑动窗口算法需要存储多份计数器，每个格子存一份，因此相比计数器算法，滑动窗口算法在实现上需要更多的存储空间。如果滑动窗口的精度越高，需要的存储空间就越大。此外，Dubbo也支持使用令牌桶算法或漏桶算法实现自定义限流Filter,并且也可以考虑分布式限流。









# 2、Dubbo安装

## 2.1、安装zookeeper

1. 下载zookeeper镜像

```bash
docker pull zookeeper
```

2. 启动容器

```bash
docker run --name zk -d -p 2181:2181 --restart=always   zookeeper
```

3. 进入容器

```bash
docker exec -it zk /bin/bash
```



## 2.2、安装Dubbo-admin

![](Dubbo(一).assets/7.png)



Dubbo-admin管理平台、图形化的服务管理页面，安装时需要指定注册中心地址，即可从注册中心获取到所有的提供者/消费者进行配置管理。

1. 下载Dubbo-Admin镜像

```bash
docker pull apache/dubbo-admin
```

2. 启动容器

```bash
docker run -d \
--name dubbo-admin \
-p 8080:8080 \
-e admin.registry.address=zookeeper://192.168.6.136:2181 \
-e admin.config-center=zookeeper://192.168.6.136:2181 \
-e admin.metadata-report.address=zookeeper://192.168.6.136:2181 \
--restart=always \
docker.io/apache/dubbo-admin
```

- `--restart`： always 每次启动docker会自动启动这个容器
- `admin.registry.address`： 注册中心
- `admin.config-center`：配置中心
- `admin.metadata-report.address`： 元数据中心

3. 访问可视化界面

浏览器访问：http://192.168.6.136:8080,用户名和密码均为root





```bash
# 重启两个容器
docker restart zk dubbo-admin

docker logs -f dubbo-admin
```











# 3、Dubbo综合实战







































